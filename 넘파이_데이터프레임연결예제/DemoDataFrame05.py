#Join 
# 데이터프레임의 join 메서드는 판다스의 merge와 유사하지만, 
# 데이터프레임의 인덱스를 기준으로 병합(merge)하는 경우 join을 사용합니다.
# 이전 절과 비슷한 예제로 join 메서드의 사용법을 익혀봅시다.
# 첫 번째 데이터프레임
from pandas import Series, DataFrame

data = [
    ["전기전자", "005930", "삼성전자", 74400],
    ["화학", "051910", "LG화학", 896000],
    ["서비스업", "035720", "카카오", 121500]
]

columns = ["업종", "종목코드", "종목명", "현재가"]
df1 = DataFrame(data=data, columns=columns)
df1 = df1.set_index("업종")

# 두 번째 데이터프레임
data = [
    ["은행", 2.92],
    ["보험", 0.37],
    ["화학", 0.06],
    ["전기전자", -2.43]
]

columns = ["항목","등락률"]
df2 = DataFrame(data=data, columns=columns)
df2 = df2.set_index("항목")

# 두 데이터프레임에 reset_index 메서드를 사용해서 인덱스를 
# 컬럼으로 변경한 뒤에 merge 함수를 사용해도 됩니다. 
# 하지만 join을 사용하면 보다 짧은 코드로 동일한 결과를 얻을 수 있습니다. 
# join 메서드에 other 파라미터로 병합할 데이터프레임을 전달합니다.
print("---join 사용하기---")
print(df1.join(other=df2))

# how 파라미터로 left/right/outer/inner 옵션을 지정할 수 있습니다. 
# how 파라미터를 사용하지 않으면 기본적으로 left 옵션이 적용됩니다. 
# 위 코드는 왼쪽(left)에 위치하는 df1 인덱스를 기준으로 
# 아래와 같이 병합됩니다.

#시가총액으로 중소형주를 구분
data = [
    ["2017", "삼성", 500],
    ["2017", "LG", 300],    
    ["2017", "SK하이닉스", 200],
    ["2018", "삼성", 600],
    ["2018", "LG", 400],
    ["2018", "SK하이닉스", 300],    
]

columns = ["연도", "회사", "시가총액"]
df = DataFrame(data=data, columns=columns)
print(df)


# 데이터프레임의 groupby를 사용하여 연도별 시가총액의 평균(mean)을 계산합니다.
# groupby 적용 시 "회사" 컬럼은 문자열이라서 자동으로 제거되고 
# 시가총액의 평균만 반환됩니다. 
# 반환되는 컬럼이 시가총액 하나라서 시리즈이기 때문에 
# to_frame 메서드를 사용해서 아래와 같은 데이터프레임을 얻습니다.
df_mean = df.groupby("연도")["시가총액"].mean().to_frame()
df_mean.columns = ['시가총액평균']
print("---시가총액평균---")
print(df_mean)

# 원본 데이터프레임 df에 join 메서드를 사용해서 
# 아래의 df_mean 데이터프레임과 병합해 보겠습니다. 
# df의 인덱스가 지정되지 않아서 set_index 메서드로 "연도" 컬럼을 지정한 후, 
# join 할 수 있습니다. 
# 하지만, 이번에는 df의 인덱스 설정 없이 
# join의 "on" 파라미터를 사용해서 한 번에 데이터를 병합해 보겠습니다.
print("---join을 사용해서 연도를 비교---")
df = df.join(df_mean, on='연도')
print(df)

# 이제 시가총액과 시가총액 평균을 비교하여 시가총액이 시가총액 평균보다 크거나 
# 같으면 '대형주'로 그렇지 않으면 '중/소형주'로 구분해 봅시다. 
# 행 단위로 조건을 나타내기 위해 numpy의 where를 사용합니다. 
# where 함수가 기억나지 않는다면 넘파이의 조건 연산을 복습해 주세요. 
import numpy as np 

print("---where사용해서 대형주,중/소형주 분류하기---")
df['규모'] = np.where(df['시가총액'] >= df['시가총액평균'],
    "대형주", "중/소형주")
print(df)

#멀티인덱스
# 엑셀에서는 셀(Cell)을 병합하는 형태로 여러 컬럼으로 구분된 
# 구조적인 데이터를 표현할 수 있습니다. 
# 데이터프레임에서는 이를 멀티인덱스라고 부릅니다. 
# 예를 들어 아래는 멀티인덱스로 표현된 데이터입니다. 
# 영업이익과 당기순이익 안에 컨센서스와 잠정치라는 하위 데이터를 계층적으로 표현합니다. 
# 판다스에서는 가장 왼쪽에 있는 영업이익과 당기순이익을 level 0 인덱스, 
# 그다음 위치인 컨센서스와 잠정치를 level 1 인덱스라고 부릅니다.
import pandas as pd 

data = [
    ['영업이익','컨센서스',1000,1200],
    ['영업이익','잠정치',900,1400],
    ['당기순이익','컨센서스',800,900],
    ['당기순이익','잠정치',700,800],
]

df = DataFrame(data=data)
df = df.set_index( [0, 1] )
print(df)

#멀티컬럼
# 테이블 상단에도 여러 줄로 구조적인 데이터를 표현할 수 있습니다. 
# 아래는 멀티 컬럼을 갖는 데이터로, 아래의 멀티인덱스를 갖는 
# 재무 데이터와 내용은 같지만 구조만 다릅니다.
data = [
    [1000,900,800,700],
    [1200,1400,900,800],
]

columns = [
    ['영업이익','영업이익','당기순이익','당기순이익'],
    ['컨센서스','잠정치','컨센서스','잠정치']
]

df = DataFrame(data=data, index=["2020/06",
    "2020/09"], columns=columns)
print(df)

# 예제의 경우 컬럼의 개수가 많지 않아 직접 지정할 수 있었지만, 
# 컬럼 개수가 많아질 경우 모든 조합을 타이핑하기 번거롭습니다. 
# 판다스 MultiIndex의 from_product 함수는 입력된 리스트로 
# 데이터의 조합을 만듭니다.
level_0 = ['영업이익','당기순이익']
level_1 = ['컨센서스','잠정치']

idx = pd.MultiIndex.from_product( [ level_0, level_1])

print(idx)
print(idx.get_level_values(0))

# 다음으로 MultiIndex의 from_product 메서드로 생성한 결과를 
# 데이터프레임으로 연결합니다. 
# 컬럼 이름을 추가하는 코드가 훨씬 간결해졌습니다.
level_0 = ['영업이익','당기순이익']
level_1 = ['컨센서스','잠정치']
columns = pd.MultiIndex.from_product( [level_0, level_1] )
df = DataFrame(data=data, 
    index=["2020/06","2020/09"], columns=columns)
print(df)

#멀티 컬럼 데이터에서 영업이익 컬럼을 인덱싱해 봅시다. 컬럼 인덱싱은 대괄호 '[ ]'를 사용합니다.
print(df['영업이익'])

# 영업이익을 인덱싱한 결과가 데이터프레임이므로 
# 다시 컬럼 인덱싱을 이어서 사용할 수 있습니다. 
# 하지만 두 번에 걸친 인덱싱은 실행 속도를 저하하므로 튜플을 
# 사용해 컬럼의 Level을 계층적으로 표현하는 것이 좋습니다.
print(df[ ('영업이익','컨센서스') ])

#다양한 컬럼 인덱싱을 사용해 본다. 
print(df[ '영업이익' ])
print(df.loc[ '2020/06', '영업이익' ])
print(df.loc[ '2020/06', ( '영업이익', '컨센서스' )])
print(df.loc[ '2020/06', ( slice(None), '컨센서스' ) ])


# 멀티 컬럼으로 표현된 데이터를 멀티 인덱스를 갖는 데이터로 
# 변환할 수 있습니다. 
# T 속성을 사용하거나 transpose 메서드를 호출하면 
# 데이터의 x축과 y축이 변경됩니다.
print(df.transpose())
print(df.T)

# 엑셀에서 가로로 긴 형태의 데이터는 마우스를 사용해서 
# 옆으로 옮겨가며 데이터를 읽어야 해 불편합니다. 
# 반대로 세로로 긴 형태의 데이터는 스크롤하기만 하면 되니 편하죠? 
# 데이터의 X/Y 축을 단순하게 변경하고 싶다면 transpose를 기억하세요.